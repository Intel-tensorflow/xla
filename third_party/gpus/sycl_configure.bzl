
"""Repository rule for SYCL autoconfiguration.
`sycl_configure` depends on the following environment variables:
  * `TF_NEED_SYCL`: Whether to enable building with SYCL.
  * `GCC_HOST_COMPILER_PATH`: The GCC host compiler path
"""

# NOTE: We now read locations from http_archive repos:
#   - @sycl_hermetic         (contains oneapi/2025.1 and oneapi/mkl/2025.1)
#   - @level_zero_redist     (contains level-zero-1.21.10/include)
#   - @ze_loader_redist      (contains lib with ze_loader)

load(
    "//third_party/remote_config:common.bzl",
    "err_out",
    "execute",
    "files_exist",
    "get_bash_bin",
    "get_host_environ",
    "get_python_bin",
    "raw_exec",
    "realpath",
    "which",
)
load(
    ":compiler_common_tools.bzl",
    "to_list_of_strings",
)
load(
    ":cuda_configure.bzl",
    "make_copy_dir_rule",
    "make_copy_files_rule",
)

_GCC_HOST_COMPILER_PATH = "GCC_HOST_COMPILER_PATH"
_GCC_HOST_COMPILER_PREFIX = "GCC_HOST_COMPILER_PREFIX"
_CLANG_HOST_COMPILER_PATH = "CLANG_COMPILER_PATH"
_CLANG_HOST_COMPILER_PREFIX = "CLANG_HOST_COMPILER_PATH"

def _repo_root_from_build(repository_ctx, build_label):
    """Return repo root dir given a :BUILD label passed via attrs."""
    return str(repository_ctx.path(build_label).dirname)
 
def _sycl_fixed_config_from_http_archives(repository_ctx):
    """Build a sycl_config with paths relative to external repos, using ONEAPI_VERSION."""
    # Read roots from attr labels (no Label() in impl)
    sycl_root = _repo_root_from_build(repository_ctx, repository_ctx.attr.sycl_build)
    l0_root   = _repo_root_from_build(repository_ctx, repository_ctx.attr.level_zero_build)
    ze_root   = _repo_root_from_build(repository_ctx, repository_ctx.attr.ze_loader_build)

    oneapi_version = get_host_environ(repository_ctx, "ONEAPI_VERSION", "") or "2025.1"

    return struct(
        sycl_basekit_path = sycl_root + "/oneapi",
        sycl_toolkit_path = sycl_root + "/oneapi/" + oneapi_version,
        sycl_version_number = "80000",
        sycl_basekit_version_number = oneapi_version,
        mkl_include_dir = sycl_root + "/oneapi/mkl/" + oneapi_version + "/include",
        mkl_library_dir = sycl_root + "/oneapi/mkl/" + oneapi_version + "/lib",
        # If your L0 archive is strip_prefixed to expose include/ at root, drop the subdir below.
        l0_include_dir = l0_root + "/include",
        # ze_loader_redist typically exposes lib/ (or lib64/) at root
        l0_library_dir = ze_root + "/lib",
    )


def _mkl_include_path(sycl_config):
    return sycl_config.mkl_include_dir

def _mkl_library_path(sycl_config):
    return sycl_config.mkl_library_dir

def _l0_include_path(sycl_config):
    return sycl_config.l0_include_dir

def _l0_library_path(sycl_config):
    return sycl_config.l0_library_dir

def _sycl_header_path(repository_ctx, sycl_config, bash_bin):
    sycl_header_path = sycl_config.sycl_toolkit_path
    include_dir = sycl_header_path + "/include"
    if not files_exist(repository_ctx, [include_dir], bash_bin)[0]:
        sycl_header_path = sycl_header_path + "/linux"
        include_dir = sycl_header_path + "/include"
        if not files_exist(repository_ctx, [include_dir], bash_bin)[0]:
            auto_configure_fail("Cannot find sycl headers in {}".format(include_dir))
    return sycl_header_path

def _sycl_include_path(repository_ctx, sycl_config, bash_bin):
    inc_dirs = []
    inc_dirs.append(_mkl_include_path(sycl_config))
    inc_dirs.append(_sycl_header_path(repository_ctx, sycl_config, bash_bin) + "/include")
    inc_dirs.append(_sycl_header_path(repository_ctx, sycl_config, bash_bin) + "/include/sycl")
    return inc_dirs

def enable_sycl(repository_ctx):
    return bool(get_host_environ(repository_ctx, "TF_NEED_SYCL", "").strip())

def _use_icpx_and_clang(repository_ctx):
    return get_host_environ(repository_ctx, "TF_ICPX_CLANG", "").strip()

def auto_configure_fail(msg):
    red = "\033[0;31m"
    no_color = "\033[0m"
    fail("\n%sAuto-Configuration Error:%s %s\n" % (red, no_color, msg))

def find_cc(repository_ctx):
    if _use_icpx_and_clang(repository_ctx):
        target_cc_name = "clang"
        cc_path_envvar = _CLANG_HOST_COMPILER_PATH
    else:
        target_cc_name = "gcc"
        cc_path_envvar = _GCC_HOST_COMPILER_PATH
    cc_name = get_host_environ(repository_ctx, cc_path_envvar) or target_cc_name
    if cc_name.startswith("/"):
        return cc_name
    cc = which(repository_ctx, cc_name)
    if cc == None:
        fail(("Cannot find {}, either correct your path or set the {}" +
              " environment variable").format(target_cc_name, cc_path_envvar))
    return cc

def find_sycl_root(repository_ctx, sycl_config):
    sycl_name = str(repository_ctx.path(sycl_config.sycl_toolkit_path.strip()).realpath)
    if sycl_name.startswith("/"):
        return sycl_name
    fail("Cannot find DPC++ compiler, please correct your path")

def find_sycl_include_path(repository_ctx, sycl_config):
    base_path = find_sycl_root(repository_ctx, sycl_config)
    bin_path = repository_ctx.path(base_path + "/bin/icpx")
    icpx_extra = ""
    if not bin_path.exists:
        bin_path = repository_ctx.path(base_path + "/bin/compiler/clang")
        if not bin_path.exists:
            fail("Cannot find DPC++ compiler, please correct your path")
    else:
        icpx_extra = "-fsycl"
    if _use_icpx_and_clang(repository_ctx):
        clang_path = repository_ctx.which("clang")
        clang_install_dir = repository_ctx.execute([clang_path, "-print-resource-dir"])
        clang_install_dir_opt = "--sysroot=" + str(repository_ctx.path(clang_install_dir.stdout.strip()).dirname)
        cmd_out = repository_ctx.execute([
            bin_path,
            icpx_extra,
            clang_install_dir_opt,
            "-xc++",
            "-E",
            "-v",
            "/dev/null",
            "-o",
            "/dev/null",
        ])
    else:
        gcc_path = repository_ctx.which("gcc")
        gcc_install_dir = repository_ctx.execute([gcc_path, "-print-libgcc-file-name"])
        gcc_install_dir_opt = "--gcc-install-dir=" + str(repository_ctx.path(gcc_install_dir.stdout.strip()).dirname)
        cmd_out = repository_ctx.execute([
            bin_path,
            icpx_extra,
            gcc_install_dir_opt,
            "-xc++",
            "-E",
            "-v",
            "/dev/null",
            "-o",
            "/dev/null",
        ])

    outlist = cmd_out.stderr.split("\n")
    include_dirs = []
    for l in outlist:
        if l.startswith(" ") and l.strip().startswith("/") and str(repository_ctx.path(l.strip()).realpath) not in include_dirs:
            include_dirs.append(str(repository_ctx.path(l.strip()).realpath))
    return include_dirs

def _lib_name(lib, version = "", static = False):
    if static:
        return "lib%s.a" % lib
    else:
        if version:
            version = ".%s" % version
        return "lib%s.so%s" % (lib, version)

def _sycl_lib_paths(repository_ctx, lib, basedir):
    file_name = _lib_name(lib, version = "", static = False)
    return [repository_ctx.path("%s/%s" % (basedir, file_name))]

def _batch_files_exist(repository_ctx, libs_paths, bash_bin):
    all_paths = []
    for _, lib_paths in libs_paths:
        for lib_path in lib_paths:
            all_paths.append(lib_path)
    return files_exist(repository_ctx, all_paths, bash_bin)

def _select_sycl_lib_paths(repository_ctx, libs_paths, bash_bin):
    test_results = _batch_files_exist(repository_ctx, libs_paths, bash_bin)
    libs = {}
    i = 0
    for name, lib_paths in libs_paths:
        selected_path = None
        for path in lib_paths:
            if test_results[i] and selected_path == None:
                selected_path = path
            i = i + 1
        if selected_path == None:
            auto_configure_fail("Cannot find sycl library %s in %s" % (name, path))
        libs[name] = struct(file_name = selected_path.basename, path = realpath(repository_ctx, selected_path, bash_bin))
    return libs

def _find_libs(repository_ctx, sycl_config, bash_bin):
    mkl_path = _mkl_library_path(sycl_config)
    libs_paths = [
        (name, _sycl_lib_paths(repository_ctx, name, path))
        for name, path in [
            ("mkl_intel_ilp64", mkl_path),
            ("mkl_sequential", mkl_path),
            ("mkl_core", mkl_path),
        ]
    ]
    if sycl_config.sycl_basekit_version_number < "2024":
        libs_paths.append(("mkl_sycl", _sycl_lib_paths(repository_ctx, "mkl_sycl", mkl_path)))
    else:
        libs_paths.append(("mkl_sycl_blas", _sycl_lib_paths(repository_ctx, "mkl_sycl_blas", mkl_path)))
        libs_paths.append(("mkl_sycl_lapack", _sycl_lib_paths(repository_ctx, "mkl_sycl_lapack", mkl_path)))
        libs_paths.append(("mkl_sycl_sparse", _sycl_lib_paths(repository_ctx, "mkl_sycl_sparse", mkl_path)))
        libs_paths.append(("mkl_sycl_dft", _sycl_lib_paths(repository_ctx, "mkl_sycl_dft", mkl_path)))
        libs_paths.append(("mkl_sycl_vm", _sycl_lib_paths(repository_ctx, "mkl_sycl_vm", mkl_path)))
        libs_paths.append(("mkl_sycl_rng", _sycl_lib_paths(repository_ctx, "mkl_sycl_rng", mkl_path)))
        libs_paths.append(("mkl_sycl_stats", _sycl_lib_paths(repository_ctx, "mkl_sycl_stats", mkl_path)))
        libs_paths.append(("mkl_sycl_data_fitting", _sycl_lib_paths(repository_ctx, "mkl_sycl_data_fitting", mkl_path)))
    l0_path = _l0_library_path(sycl_config)
    libs_paths.append(("ze_loader", _sycl_lib_paths(repository_ctx, "ze_loader", l0_path)))
    return _select_sycl_lib_paths(repository_ctx, libs_paths, bash_bin)

def find_sycl_config(repository_ctx):
    # Kept for compatibility; unused in fixed-path flow.
    python_bin = get_python_bin(repository_ctx)
    exec_result = execute(repository_ctx, [python_bin, repository_ctx.attr._find_sycl_config])
    if exec_result.return_code:
        auto_configure_fail("Failed to run find_sycl_config.py: %s" % err_out(exec_result))
    return dict([tuple(x.split(": ")) for x in exec_result.stdout.splitlines()])

def _get_sycl_config(repository_ctx, bash_bin):
    # Kept for compatibility; unused in fixed-path flow.
    config = find_sycl_config(repository_ctx)
    return struct(
        sycl_basekit_path = config["sycl_basekit_path"],
        sycl_toolkit_path = config["sycl_toolkit_path"],
        sycl_version_number = config["sycl_version_number"],
        sycl_basekit_version_number = config["sycl_basekit_version_number"],
        mkl_include_dir = config["mkl_include_dir"],
        mkl_library_dir = config["mkl_library_dir"],
        l0_include_dir = config["l0_include_dir"],
        l0_library_dir = config["l0_library_dir"],
    )

def _tpl_from_attr(repository_ctx, label_attr, substitutions = {}, out = None):
    src = repository_ctx.path(label_attr)
    dst = out or src.basename
    repository_ctx.template(dst, src, substitutions)



_INC_DIR_MARKER_BEGIN = "#include <...>"

def _normalize_include_path(repository_ctx, path):
    path = str(repository_ctx.path(path))
    crosstool_folder = str(repository_ctx.path(".").get_child("crosstool"))
    if path.startswith(crosstool_folder):
        return "\"" + path[len(crosstool_folder) + 1:] + "\""
    return "\"" + path + "\""

def _get_cxx_inc_directories_impl(repository_ctx, cc, lang_is_cpp):
    lang = "c++" if lang_is_cpp else "c"
    result = raw_exec(repository_ctx, [cc, "-no-canonical-prefixes", "-E", "-x" + lang, "-", "-v"])
    stderr = err_out(result)
    index1 = stderr.find(_INC_DIR_MARKER_BEGIN)
    if index1 == -1:
        return []
    index1 = stderr.find("\n", index1)
    if index1 == -1:
        return []
    index2 = stderr.rfind("\n ")
    if index2 == -1 or index2 < index1:
        return []
    index2 = stderr.find("\n", index2 + 1)
    if index2 == -1:
        inc_dirs = stderr[index1 + 1:]
    else:
        inc_dirs = stderr[index1 + 1:index2].strip()
    return [str(repository_ctx.path(p.strip())) for p in inc_dirs.split("\n")]

def get_cxx_inc_directories(repository_ctx, cc):
    includes_cpp = _get_cxx_inc_directories_impl(repository_ctx, cc, True)
    includes_c = _get_cxx_inc_directories_impl(repository_ctx, cc, False)
    includes_cpp_set = depset(includes_cpp)
    return includes_cpp + [inc for inc in includes_c if inc not in includes_cpp_set.to_list()]

_DUMMY_CROSSTOOL_BZL_FILE = """
def error_gpu_disabled():
  fail("ERROR: Building with --config=sycl but TensorFlow is not configured " +
       "to build with GPU support. Please re-run ./configure and enter 'Y' " +
       "at the prompt to build with GPU support.")

  native.genrule(
      name = "error_gen_crosstool",
      outs = ["CROSSTOOL"],
      cmd = "echo 'Should not be run.' && exit 1",
  )

  native.filegroup(
      name = "crosstool",
      srcs = [":CROSSTOOL"],
      output_licenses = ["unencumbered"],
  )
"""

_DUMMY_CROSSTOOL_BUILD_FILE = """
load("//crosstool:error_gpu_disabled.bzl", "error_gpu_disabled")

error_gpu_disabled()
"""

def _create_dummy_repository(
        repository_ctx,
        sycl_libs = None,
        mkl_sycl_libs = None,
        copy_rules = None,
        level_zero_libs = None,
        level_zero_headers = None):
    sycl_libs = sycl_libs or []
    mkl_sycl_libs = mkl_sycl_libs or []
    copy_rules = copy_rules or []
    level_zero_libs = level_zero_libs or []
    level_zero_headers = level_zero_headers or []

    repository_ctx.file("crosstool/error_gpu_disabled.bzl", _DUMMY_CROSSTOOL_BZL_FILE)
    repository_ctx.file("crosstool/BUILD", _DUMMY_CROSSTOOL_BUILD_FILE)

    # Templated files via attr labels (no Label() in impl)
    _tpl_from_attr(
        repository_ctx,
        repository_ctx.attr._tpl_sycl_build_defs,
        {
            "%{sycl_is_configured}": "False",
            "%{sycl_build_is_configured}": "False",
        },
        out = "sycl/build_defs.bzl",
    )

    _tpl_from_attr(
        repository_ctx,
        repository_ctx.attr._tpl_sycl_BUILD,
        {
            "%{mkl_intel_ilp64_src}": "",
            "%{mkl_sequential_src}": "",
            "%{mkl_core_src}": "",
            "%{mkl_sycl_srcs}": "",
            "%{mkl_intel_ilp64_lib}": "",
            "%{mkl_sequential_lib}": "",
            "%{mkl_core_lib}": "",
            "%{mkl_sycl_libs}": "",
            "%{level_zero_libs}": "",
            "%{level_zero_headers}": "",
            "%{sycl_headers}": "",
            "%{copy_rules}": "\n".join(copy_rules) if copy_rules else "",
        },
        out = "sycl/BUILD",
    )


def _create_local_sycl_repository(repository_ctx):
    bash_bin = get_bash_bin(repository_ctx)

    # Use fixed directories derived from http_archive repos (via attrs).
    sycl_config = _sycl_fixed_config_from_http_archives(repository_ctx)

    # Copy header and library files to execroot.
    copy_rules = [
        make_copy_dir_rule(
            repository_ctx,
            name = "sycl-include",
            src_dir = _sycl_header_path(repository_ctx, sycl_config, bash_bin) + "/include",
            out_dir = "sycl/include",
        ),
        make_copy_dir_rule(
            repository_ctx,
            name = "mkl-include",
            src_dir = _mkl_include_path(sycl_config),
            out_dir = "mkl/include",
        ),
        make_copy_dir_rule(
            repository_ctx,
            name = "level-zero-include",
            src_dir = _l0_include_path(sycl_config),
            out_dir = "level_zero/include",
        ),
    ]

    sycl_libs = _find_libs(repository_ctx, sycl_config, bash_bin)
    sycl_lib_srcs = []
    sycl_lib_outs = []
    for lib in sycl_libs.values():
        sycl_lib_srcs.append(lib.path)
        sycl_lib_outs.append("sycl/lib/" + lib.file_name)
    copy_rules.append(make_copy_files_rule(
        repository_ctx,
        name = "sycl-lib",
        srcs = sycl_lib_srcs,
        outs = sycl_lib_outs,
    ))

    # sycl/build_defs.bzl from template attr
    _tpl_from_attr(
        repository_ctx,
        repository_ctx.attr._tpl_sycl_build_defs,
        {"%{sycl_is_configured}": "True", "%{sycl_build_is_configured}": "True"},
        out = "sycl/build_defs.bzl",
    )

    if sycl_config.sycl_basekit_version_number < "2024":
        mkl_sycl_libs = '"{}"'.format("sycl/lib/" + sycl_libs["mkl_sycl"].file_name)
    else:
        mkl_sycl_libs = '"{}",\n"{}",\n"{}",\n"{}",\n"{}",\n"{}",\n"{}",\n"{}",\n'.format(
            "sycl/lib/" + sycl_libs["mkl_sycl_blas"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_lapack"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_sparse"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_dft"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_vm"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_rng"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_stats"].file_name,
            "sycl/lib/" + sycl_libs["mkl_sycl_data_fitting"].file_name,
        )
    level_zero_libs = '"{}",\n'.format("sycl/lib/" + sycl_libs["ze_loader"].file_name)

    def _fmt_src(path):
        return '"%s",\n' % path

    # sycl/BUILD from template attr
    _tpl_from_attr(
        repository_ctx,
        repository_ctx.attr._tpl_sycl_BUILD,
        {
            "%{mkl_intel_ilp64_src}": _fmt_src("sycl/lib/" + sycl_libs["mkl_intel_ilp64"].file_name),
            "%{mkl_sequential_src}": _fmt_src("sycl/lib/" + sycl_libs["mkl_sequential"].file_name),
            "%{mkl_core_src}": _fmt_src("sycl/lib/" + sycl_libs["mkl_core"].file_name),
            "%{mkl_sycl_srcs}": mkl_sycl_libs,
            "%{mkl_intel_ilp64_lib}": sycl_libs["mkl_intel_ilp64"].file_name,
            "%{mkl_sequential_lib}": sycl_libs["mkl_sequential"].file_name,
            "%{mkl_core_lib}": sycl_libs["mkl_core"].file_name,
            "%{mkl_sycl_libs}": mkl_sycl_libs,
            "%{copy_rules}": "\n".join(copy_rules),
            "%{sycl_headers}": '":mkl-include",\n":sycl-include",\n',
            "%{level_zero_libs}": level_zero_libs,
            "%{level_zero_headers}": '":level-zero-include"',
        },
        out = "sycl/BUILD",
    )

    # crosstool/
    is_icpx_and_clang = _use_icpx_and_clang(repository_ctx)
    cc = find_cc(repository_ctx)

    host_compiler_includes = get_cxx_inc_directories(repository_ctx, cc)
    clang_host_compiler_prefix = get_host_environ(repository_ctx, _CLANG_HOST_COMPILER_PREFIX, "/usr/bin")
    gcc_host_compiler_prefix = get_host_environ(repository_ctx, _GCC_HOST_COMPILER_PREFIX, "/usr/bin")

    sycl_defines = {}
    sycl_defines["%{host_compiler_path}"] = "clang/bin/crosstool_wrapper_driver_sycl"
    if is_icpx_and_clang:
        sycl_defines["%{extra_no_canonical_prefixes_flags}"] = "\"-no-canonical-prefixes\""
        sycl_defines["%{host_compiler_prefix}"] = clang_host_compiler_prefix
    else:
        sycl_defines["%{extra_no_canonical_prefixes_flags}"] = "\"-fno-canonical-system-headers\""
        sycl_defines["%{host_compiler_prefix}"] = gcc_host_compiler_prefix

    sycl_defines["%{ar_path}"] = "clang/bin/ar_driver_sycl"
    sycl_defines["%{cpu_compiler}"] = str(cc)
    sycl_defines["%{linker_bin_path}"] = "/usr/bin"

    sycl_internal_inc_dirs = find_sycl_include_path(repository_ctx, sycl_config)
    cxx_builtin_includes_list = sycl_internal_inc_dirs + _sycl_include_path(repository_ctx, sycl_config, bash_bin) + host_compiler_includes

    # Optionally force-add oneAPI compiler resource dirs
    oneapi_toolkit = sycl_config.sycl_toolkit_path
    forced_oneapi_dirs = [
        oneapi_toolkit + "/opt/compiler/include",
        oneapi_toolkit + "/lib/clang/20/include",
    ]

    # Deduplicate while preserving order
    seen = {}
    deduped = []
    for p in cxx_builtin_includes_list + forced_oneapi_dirs:
        if p not in seen:
            seen[p] = True
            deduped.append(p)

    sycl_defines["%{cxx_builtin_include_directories}"] = to_list_of_strings(deduped)
    sycl_defines["%{unfiltered_compile_flags}"] = to_list_of_strings([
        "-DTENSORFLOW_USE_SYCL=1",
        "-DMKL_ILP64",
        "-fPIC",
    ])
    sycl_defines["%{sycl_compiler_root}"] = str(sycl_config.sycl_toolkit_path)
    sycl_defines["%{SYCL_ROOT_DIR}"] = str(sycl_config.sycl_toolkit_path)
    sycl_defines["%{basekit_path}"] = str(sycl_config.sycl_basekit_path)
    sycl_defines["%{basekit_version}"] = str(sycl_config.sycl_basekit_version_number)

    # crosstool files from template attrs
    _tpl_from_attr(repository_ctx, repository_ctx.attr._tpl_crosstool_BUILD,                sycl_defines, out = "crosstool/BUILD")
    _tpl_from_attr(repository_ctx, repository_ctx.attr._tpl_crosstool_cc_toolchain_config, sycl_defines, out = "crosstool/cc_toolchain_config.bzl")
    _tpl_from_attr(repository_ctx, repository_ctx.attr._tpl_crosstool_wrapper,             sycl_defines, out = "crosstool/clang/bin/crosstool_wrapper_driver_sycl")
    _tpl_from_attr(repository_ctx, repository_ctx.attr._tpl_ar_driver,                     sycl_defines, out = "crosstool/clang/bin/ar_driver_sycl")


def _sycl_autoconf_imp(repository_ctx):
    """Implementation of the sycl_autoconf rule."""
    if not enable_sycl(repository_ctx):
        _create_dummy_repository(repository_ctx)
    else:
        _create_local_sycl_repository(repository_ctx)

sycl_configure = repository_rule(
    implementation = _sycl_autoconf_imp,
    local = True,
    attrs = {
        "_find_sycl_config": attr.label(
            default = Label("//third_party/gpus:find_sycl_config.py"),
            allow_single_file = True,
        ),
        # external repo roots
        "sycl_build": attr.label(
            default = Label("@sycl_hermetic//:BUILD"),
            allow_single_file = True,
        ),
        "level_zero_build": attr.label(
            default = Label("@level_zero_redist//:BUILD"),
            allow_single_file = True,
        ),
        "ze_loader_build": attr.label(
            default = Label("@ze_loader_redist//:BUILD"),
            allow_single_file = True,
        ),
        # template files (NO Label() in impl)
        "_tpl_sycl_build_defs": attr.label(
            default = Label("//third_party/gpus/sycl:build_defs.bzl.tpl"),
            allow_single_file = True,
        ),
        "_tpl_sycl_BUILD": attr.label(
            default = Label("//third_party/gpus/sycl:BUILD.tpl"),
            allow_single_file = True,
        ),
        "_tpl_crosstool_BUILD": attr.label(
            default = Label("//third_party/gpus/crosstool:BUILD.sycl.tpl"),
            allow_single_file = True,
        ),
        "_tpl_crosstool_cc_toolchain_config": attr.label(
            default = Label("//third_party/gpus/crosstool:sycl_cc_toolchain_config.bzl.tpl"),
            allow_single_file = True,
        ),
        "_tpl_crosstool_wrapper": attr.label(
            default = Label("//third_party/gpus/crosstool/clang/bin:crosstool_wrapper_driver_sycl.tpl"),
            allow_single_file = True,
        ),
        "_tpl_ar_driver": attr.label(
            default = Label("//third_party/gpus/crosstool/clang/bin:ar_driver_sycl.tpl"),
            allow_single_file = True,
        ),
    },
)
